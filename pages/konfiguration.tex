\section{Konfiguration und Implementierung}\label{konfiguration-u-impl}
Nachdem die Entscheidung über die zu verwendende Architektur getroffen ist,
folgt nun die Konfiguration der einzelnen Komponenten. Im ersten Schritt wird
Tutors als Aufgabensammlung erläutert. Danach geht es um die Automatisierung der
Benotung und der Quellcodeverwaltung mit GitHub Classroom. Anschließend folgt
die Erstellung und Programmierung eines Template-Repositorys, welches diverse
Hilfsprogramme enthält, um den Workflow für den Studierenden zu erleichtern.

% Tutors.dev
\subsection{Tutors als Aufgabensammlung}\label{tutors-als-aufgabensammlung}
Da der Programmierkurs nur ein Teil eines ganzen Modulkatalogs des Studiums
Digital Skills ist, übernehmen die Einrichtung Konfiguration von Tutors die
hierfür zuständigen wissenschaftlichen Mitarbeitenden des Zusatzstudiums.

Für die Einpflegung der Aufgaben werden lediglich Anleitungen sowie
jeweils dazugehörige Thumbnails (Vorschaubilder) benötigt. Die Anleitungen
werden, wie in Unterabschnitt \ref{finale-architektur-tutors} genauer erläutert,
im standardisierten und weit verbreiteten Format Markdown verfasst.

Anleitungen können durch Markdown mit verhältnismäßig wenig Aufwand verfasst
werden und schließlich als \code{README.md}-Datei im Aufgaben-Repository
abgelegt werden. Dies hat den Vorteil, dass die Anleitung auch in der
Versionskontrolle der Aufgabe enthalten sind. Außerdem können GitHub und Replit
beim Klick auf die Aufgabe die Anleitung neben Tutors auch zusätzlich
formatiert anzeigen.

% GitHub Classroom
\subsection{GitHub Classroom}\label{github-classroom}
\subsubsection{Konfiguration}\label{classroom-konfiguration}
Für die Einrichtung wird eine GitHub Organisation erstellt. GitHub
Organisationen können von jedem GitHub-User erstellt werden und benötigen
lediglich einen Namen und eine Kontakt-E-Mail-Adresse
\parencite{github-organisation-erstellen}. Die Organisation dieses Kurses
beherbergt alle Aufgabenvorlagen, die später näher erläuterte Vorlage für
Replit, sowie alle Aufgabenrepositorys der Studierenden.

\subsubsection{Erste Aufgaben}\label{classroom-erste-aufgaben}
Nach der Erstellung der OTH-Organisation werden die Aufgabenvorlagen erstellt.
Aufgabenvorlagen sind in GitHub Classroom normale Repositorys, welche in GitHub
als Template markiert wurden. Sie beinhalten meist zusätzlich Unit-Tests, um den
Code darin zu prüfen.

Sobald die Organisation mit Aufgaben gefüllt ist, kann der
Classroom für den Kurs angelegt werden. Anfangs ist ein Classroom, wie die
Organisation auch, leer. Über die Oberfläche können neue Assignments
erstellt werden. Assignments sind Aufgaben, welche dem Studierenden zur
Verfügung stehen. Für jedes vorher angelegte Aufgabenrepository wird ein
Assignment erstellt. Bei der Erstellung gibt man verschiedene
Konfigurationsparameter an. Dazu gehört die Auswahl, ob eine Aufgabe von
Einzelpersonen oder einer Gruppe bearbeitet werden kann, oder ob die jeweiligen
Versuche für alle Studierenden oder nur für die Lehrenden sichtbar sind. Ferner
gibt es die Möglichkeit eine Deadline, sowie den Starter Code anzugeben. Für den
Starter Code wird in diesem Fall jeweils das Aufgabenrepository ausgewählt.
\parencite{github-assignment-erstellen}

\subsubsection{Tests und Benotung}\label{classroom-tests}
Im nächsten Schritt legt man die Benotung und das Feedback fest. Das Autograding
(die Benotung) geschieht über Kommandos in der Konsole. Im vorliegenden Fall
beinhaltet jedes Aufgabenrepository einen Ordner mit pytest-Tests. Pytest ist
eine Code-Test-Bibliothek für Python. Die Assignments wurden so konfiguriert,
dass GitHub nach jedem Push zum Repository des Studierenden die pytest-Tests
startet. Wenn alle Tests erfolgreich sind, erhält der Studierende eine
vorkonfigurierte Punktzahl. Durch Classroom ist es außerdem möglich, jedem
Test eine individuelle Punktzahl zuzuweisen. So kann man dem Schüler neben der
erfolgreichen Ausführung beispielsweise noch Bonuspunkte für das Berücksichtigen
von nicht geplanten Eingaben vergeben. \parencite{github-assignment-erstellen}

\newpage

% Replit
\subsection{Erstellung eines Replit-Starter-Templates}\label{replit-template}
Sobald die Anleitungen in Tutors veröffentlicht und die Aufgaben in GitHub
Classroom als Assignments erstellt wurden, folgt nun die Konfiguration von
Replit. Damit der Workflow der Studierenden mit der Online-IDE unterstützt wird,
wird ein dafür hilfreiches Template-Repository erstellt.

\subsubsection{Template-Repository}\label{replit-template-repository}
Projekte in Replit heißen \emph{Repls}. Ein Projekt ist in Replit ein
vollumfänglicher Arbeitsbereich, um neue oder bestehende Software zu entwickeln.
Neben einer Dateiübersicht, einem Texteditor und einer Konsole enthält der
Arbeitsbereich viele weitere Funktionen. Dazu zählt unter anderem eine
eingebaute Oberfläche für die Versionskontrolle Git, ein Quellcode-Debugger,
eine lokale Key-Value-Datenbank, private Umgebungsvariablen, sowie ein
spezieller Bereich für Unit-Tests.

Repls können auf Basis von bestehenden GitHub Repositorys erzeugt werden. Durch
den Import eines Repositorys, werden alle im Repository vorhandenen Dateien
in den neuen Arbeitsbereich kopiert. Diese Funktionalität ermöglicht das
Bereitstellen von Hilfsprogrammen und Dateien, die die Bearbeitung der
Kursaufgaben für den Teilnehmenden erleichtern.

Aus diesem Grund wurde ein öffentliches Repository in der vorher erstellten
GitHub Organisation angelegt. Dies ist das Template, welches später von den
Studierenden als Starter-Vorlage verwendet wird.
\parencite{git-repo:replit-template} Replit versteckt alle Dateien, welche sich
in einem Ordner namens \texttt{node\_modules} befinden. Normalerweise wird der
Ordner automatisch im Kontext mit externen Modulen der JavaScript-Bibliothek
Node.js verwendet \parencite{nodejs}. Das ist auch der Grund, weshalb Replit
diesen Ordner automatisch versteckt. Dieses Verhalten nutzen wir, um
Hilfsprogramme und Konfigurationen zu verstecken.

Studierende werden den ganzen Kurs in einem einzigen Repl absolvieren. Jede
Programmieraufgabe wird als Ordner im Repl Arbeitsbereich abgespeichert. Um die
Aufgaben herunterladen, prüfen und schließlich abgeben zu können, benötigt man
Git-Kenntnisse, sowie Erfahrungen mit Test-Frameworks, wie zum Beispiel pytest.
Im \texttt{node\_modules}-Ordner des Starter-Templates befinden sich diverse
Hilfsprogramme, welche den Studierenden bei der Einrichtung und Verwaltung der
Programmieraufgaben unterstützen.

\subsubsection{Hilfsprogramme (get, check, submit)}
\label{replit-template-wrapper-tools}
Die Kommandozeilen-Tools \texttt{get}, \texttt{check} und \texttt{submit} sind
\ac{bash} Skripte. Über den Konsolenbefehl \texttt{get <PROJEKT-REPOSITORY>}
kann der Studierende die Aufgabe in seinen Arbeitsbereich (Repl) laden. Das
Skript durchsucht die im Code definierte Organisation nach einem Repository mit
dem Namen und lädt es schließlich über den Befehl \code{git clone} in den
Arbeitsbereich.

Der Befehl \texttt{check <PROJEKT-REPOSITORY>} erlaubt es, die Aufgabe auf
Fehler überprüfen zu lassen. In jedem Aufgabenrepository befindet sich eine
\texttt{.language}-Datei, welche die für die Aufgabe verwendete
Programmiersprache enthält. Das \texttt{check}-Skript liest die
\texttt{.language}-Datei aus und entscheidet daraufhin, welche Befehle zum
Ausführen der Tests nötig sind. Python ist die vom Zusatzstudium Digital Skills
verwendete Programmiersprache. In diesem Fall installiert das Skript zuerst die
nötigen Abhängigkeiten mit

\begin{lstlisting}[style=Bash]
$ pip3 install pytest --quiet
\end{lstlisting}

Der Parameter \code{-{}-quiet} verhindert für den Teilnehmer unübersichtliche
Konsolenausgaben. Sobald das Testframework für Python installiert ist, führt das
Skript den Befehl \code{pytest} aus und startet somit die Ausführung der
Unit-Tests.

Schließlich pusht der Befehl \texttt{submit <PROJEKT-REPOSITORY>}
den Lösungsversuch in das GitHub Classroom Aufgabenrepository des
Kursteilnehmers. Dazu überprüft das Skript zuerst, ob es in der Zwischenzeit
Änderungen am Repository gab und lädt diese herunter. Anschließend erstellt
das Skript einen automatisierten Commit und lädt diesen in das Remote-Repository
in die GitHub-Organisation des Kurses hoch.

Damit die Skripte ordnerunabhängig ausgeführt werden können, werden
Konsolenaliase benötigt. Konsolenaliase können in einer Bash-Konsole
beispielsweise über das Anhängen folgender Zeile an die \texttt{.bashrc}-Datei
erstellt werden:

\begin{lstlisting}[style=Bash]
$ alias befehl="echo Hallo"
\end{lstlisting}

Bash ist eine Art \glqq Standard-Shell\grqq{} unter Linux und wird auch von
Replit als Konsole eingesetzt \parencite{bash}. Bei jeder neuen Konsolensitzung
wird dann der Alias aus der Datei eingelesen und angewendet. Die genannte Datei
befindet sich in der Regel im Benutzerverzeichnis, welches außerhalb des
Arbeitsbereiches in Replit liegt. Alle Änderungen außerhalb des Arbeitsbereiches
werden jedoch von Replit nach jeder Sitzung zurückgesetzt. Um dieses Problem zu
umgehen, wurde die nun folgende \emph{OTH-Console} entwickelt.

\subsubsection{OTH-Console}\label{replit-template-oth-console}
Sobald der Studierende in seinem Repl auf den Run-Knopf drückt, startet die
sogenannte OTH-Console in der Konsole. Dies ist eine neue
modifizierte Konsoleninstanz, welche alle für die Arbeit benötigten
Konfigurationen enthält.

Beim Start der OTH-Console beginnt die Ausführung des Einrichtungsskripts
\texttt{setup.py}, welches die benötigten Dateien in das Benutzerverzeichnis
schreibt.

Zuerst wird eine Konfigurationsdatei für Bash angelegt. In diese werden alle
benötigten Aliase (\texttt{get}, \texttt{submit}, \texttt{check} und
\texttt{github}) geschrieben. Außerdem wird GitHub, falls noch nicht vorhanden,
zu den sogenannten \emph{Known Hosts} im SSH-Ordner hinzugefügt. Der Vorteil
daran ist, dass der Studierende bei der ersten Verbindung mit GitHub (bspw. durch
den \texttt{get}-Befehl) keine SSH-Authentizitätsprüfung bestätigen muss
\parencite{ssh}. Als letztes wird in der Konfigurationsdatei noch das Aussehen
des \emph{Bash Promptes} festgelegt.

Im nächsten Schritt wird die passwortlose Authentifizierung mit GitHub
eingerichtet. Hierzu benötigt man ein SSH-Schlüssel-Paar, welches automatisch,
falls nicht vorhanden, durch das Einrichtungsskript erzeugt wird. Nach der
Erzeugung wird es neben dem SSH-Ordner auch in die Repl-Nutzer-Datenbank
geschrieben. Die Datebank ist ein simpler Key-Value-Speicher, welcher jeweils
pro Replit-Projekt existiert \parencite{replit-database}. Sobald der Studierende
Replit neu startet und das Benutzerverzeichnis gelöscht wurde, holt sich das
Einrichtungsskript die SSH-Keys aus der Datenbank und schreibt sie wieder
zurück in die jeweiligen Dateien. Dasselbe Verfahren wird ebenfalls für die
Konfiguration von Git angewandt. Git benötigt, um Commits zu pushen, einen 
Namen mit zugehöriger E-Mail-Adresse \parencite{git-config}. Diese Daten werden
zusammen mit den SSH-Keys in der Replit-Datenbank gespeichert.

Nach der Ausführung des Einrichtungsskripts, wird eine neue
Bash-Konsolen-Instanz, mit der gerade angelegten Konfigurationsdatei als
Parameter, gestartet.

\subsubsection{SSH-Keys}\label{replit-template-ssh-keys}
Um das vorher generierte SSH-Schlüsselpaar für die Authentifizierung gegen
GitHub zu verwenden, muss der öffentliche Schlüssel noch zu dem GitHub-Profil
des Studierenden hinzugefügt werden. Hierfür enthält das Starter-Template ein
weiteres Programm auf Basis von Python, welches mit dem Befehl \texttt{github}
in der OTH-Console ausgeführt werden kann. Dieses weitere Tool lädt den im
SSH-Ordner gespeicherten öffentlichen Schlüssel und gibt ihn zusammen mit einem
Link zum Hinzufügen von SSH-Keys in GitHub aus.

Des Weiteren überprüft das Programm, ob Git bereits konfiguriert ist. Um Commits
zu erstellen, benötigt Git wie vorher bereits erwähnt einen Namen sowie eine
dazugehörige E-Mail-Adresse. Sind die benötigten Werte nicht in der
Replit-Datenbank vorhanden, fragt das Programm den Nutzenden nach dem Namen und
der studentischen E-Mail-Adresse. Nach gültiger Eingabe der Daten werden diese
Werte in der nutzerspezifischen Replit-Datenbank des Arbeitsbereiches
hinterlegt. Damit Git die Werte übernehmen kann, werden sie, wie beim
Einrichtungsskript auch, in eine dafür vorgesehene Git-Konfigurationsdatei
geschrieben.